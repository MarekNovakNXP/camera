<!doctype html>
<html lang="en">
<head>

	<title>Camera</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
     <script src="//ajax.googleapis.com/ajax/libs/jqueryui/1.10.3/jquery-ui.min.js"></script>
    
    <script src="js/lib/threejs/three.min.js"></script>

    <script src="js/lib/threejs/shaders/CopyShader.js"></script>
    <script src="js/ThresholdShader.js"></script>
    <script src="js/WarpShader.js"></script>
    
    <script src="js/lib/threejs/postprocessing/EffectComposer.js"></script>
    <script src="js/lib/threejs/postprocessing/RenderPass.js"></script>
    <script src="js/lib/threejs/postprocessing/ShaderPass.js"></script>
    <script src="js/lib/threejs/postprocessing/MaskPass.js"></script>
    
    <script src="js/lib/stats.min.js"></script>
    <script type="text/javascript" src="js/lib/dat.gui.min.js"></script>
    
    <script src="js/webcam.js"></script>
    <script src="js/homography.js"></script>
    <script src="js/warp.js"></script>
    
     <link href="css/style.css" rel="stylesheet" type="text/css">
    
</head>

<body>

<video id="video" autoplay width="640" height="480" class="hidden"></video>

<div id="container">
  <div id="crop">
    <canvas id="vertexCanvas" width="640" height="480"></canvas>
    <div id="vertexcontainer">
      <div id="vertex0" class="vertex" data-vertexnumber="0"><div class="handle">P0</div></div>
      <div id="vertex1" class="vertex" data-vertexnumber="1"><div class="handle">P1</div></div>
      <div id="vertex2" class="vertex" data-vertexnumber="2"><div class="handle">P2</div></div>
      <div id="vertex3" class="vertex" data-vertexnumber="3"><div class="handle">P3</div></div>
    </div>
  </div>
</div>

<script>
var SCREEN_HEIGHT = 480;
var SCREEN_WIDTH = 640;
var homographyMatrix = Array();

var configThreshold = {
  soft: 0.001,
  threshold: 0.3
};

var container, scene, camera, renderer, composer, viewThreshold;
var video, videoTexture;
var warpEffect, thresholdEffect;


init();
animate();
		
function init() 
{

  webcam('video');

  stats = new Stats();
  stats.domElement.style.position	= 'absolute';
  stats.domElement.style.bottom	= '0px';
  document.body.appendChild( stats.domElement );

  var gui = new dat.GUI();
  gui.add(configThreshold, 'threshold',0,1).onChange(function(value) {
      thresholdEffect.uniforms[ 'threshold' ].value = configThreshold['threshold'];
  });
  gui.add(configThreshold, 'soft',0,1).onChange(function(value) {
      thresholdEffect.uniforms[ 'soft' ].value = configThreshold['soft'];
  });

  scene = new THREE.Scene();

  camera = new THREE.Camera();
  scene.add(camera);

  renderer = new THREE.WebGLRenderer();
  renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
  renderer.domElement.width = SCREEN_WIDTH;
  renderer.domElement.height = SCREEN_HEIGHT;
  renderer.autoClear = false;
  container = document.getElementById( 'container' );
  container.insertBefore(renderer.domElement, container.firstChild);

  video = document.getElementById( 'video' );
  videoTexture = new THREE.Texture( video );
  
  viewThreshold = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), new THREE.MeshBasicMaterial( { map: videoTexture } ) );

  viewThreshold.material.depthTest = false;
  viewThreshold.material.depthWrite = false;
  scene.add(viewThreshold);

  // postprocessing
  composer = new THREE.EffectComposer( renderer );
  composer.addPass( new THREE.RenderPass( scene, camera ) );

  thresholdEffect = new THREE.ShaderPass( THREE.ThresholdShader );
  thresholdEffect.uniforms[ 'soft' ].value = configThreshold['soft'];
  thresholdEffect.uniforms[ 'threshold' ].value = configThreshold['threshold'];
  composer.addPass( thresholdEffect );

  warpEffect = new THREE.ShaderPass( THREE.WarpShader );
  warpEffect.renderToScreen = true;
  composer.addPass( warpEffect );
  
}

function animate() 
{
  requestAnimationFrame( animate );
	if ( video.readyState === video.HAVE_ENOUGH_DATA )
    videoTexture.needsUpdate = true;
  composer.render();
  stats.update();
}

$(function() {

    updateCrop = function() {
  
        var canvas = document.getElementById("vertexCanvas");
        var context = canvas.getContext("2d");
        
        //vertices of crop box
        var p = [
          new THREE.Vector2(),
          new THREE.Vector2(),
          new THREE.Vector2(),
          new THREE.Vector2()
        ];
        //This is always the original source state
        var screen = [
          new THREE.Vector2(0,0),
          new THREE.Vector2(1,0),
          new THREE.Vector2(1,1),
          new THREE.Vector2(0,1)
        ];
       /* var polygon = [
          new THREE.Vector2(0,0),
          new THREE.Vector2(.25,0),
          new THREE.Vector2(.25,.25),
          new THREE.Vector2(0,.25)
        ];*/
        context.strokeStyle = "rgba(0, 100, 200,0.5)";
        context.fillStyle = "rgba(0, 100, 200,0.15)";
        context.clearRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT );
  
        //calculate and display the crop box and vertices
        context.beginPath();
        var first = true;

        $("#vertexcontainer .vertex").each(function() {
            var position = $(this).position();
            var i = $(this).attr('data-vertexnumber');
            var x = position.left;
            var y = position.top;
            p[i].x =  x / SCREEN_WIDTH;
            p[i].y =  y / SCREEN_HEIGHT;
            if (first) {
                context.moveTo(x, y);
                first = false;
            } else {
                context.lineTo(x, y);
            }
        });
        context.closePath();
        context.stroke();
        context.fill();
  
        homographyMatrix = findHomography(screen,p);
        var h = homographyMatrix;
        //create a ofMatrix4x4 in column order
        var m = new THREE.Matrix4(h[0], h[4],h[8], h[12],
                              h[1], h[5],h[9], h[13],
                              h[2], h[6],h[10],h[14],
                              h[3], h[7],h[11],h[15]);
       // m.getInverse(m); //BROKEN
        warpEffect.uniforms[ 'm' ].value = m;
  
        //warp debug output
        /*context.beginPath();
        first = true;
        for(i = 0; i < 4; i++){
          polygon[i] = fromWarpToScreenCoord(polygon[i].x,polygon[i].y,homographyMatrix);
          if (first) {
              context.moveTo(polygon[i].x*SCREEN_WIDTH, polygon[i].y*SCREEN_HEIGHT);
              first = false;
          } else {
              context.lineTo(polygon[i].x*SCREEN_WIDTH, polygon[i].y*SCREEN_HEIGHT);
          }
        }
        context.closePath();
        context.strokeStyle="red";
        context.stroke();
        context.fillStyle="red";
        context.fill();*/
  

    };

    $( ".vertex" ).draggable({
        stack: "div",
        snap: true,
        handle: "div.handle",
        start: function() {
            $(".currenthandle").removeClass("currenthandle");
            $(this).children("div.handle").addClass("currenthandle");
        },
        drag: updateCrop,
        stop: updateCrop
    });
  
   updateCrop();
});
</script>
</body>
</html>